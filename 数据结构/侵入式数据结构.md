## 侵入式数据结构

> 侵入式数据结构是一种将“无数据的结构节点”嵌入到业务数据类型中去，而非封装数据的通用数据结构实现方式，核心是让数据本身承载结构关系，而非结构单独管理数据。



### 概述

我们日常学习与开发中常见的是非侵入式数据结构，即通过封装数据实现通用，例如 C++ 中的`std::list`、`std::unordered_map` ；而侵入式结构通过“数据嵌入节点”的方式实现通用，核心是让数据本身承载结构关系，而非结构单独管理数据。通过这种方式，数据结构代码仅处理节点间的关系，业务数据则通过地址偏移从节点反向获取。



### 示例

假设我们要管理 3 个学生的姓名和学号，用侵入式链表让他们按学号排队，数据结构定义如下：

```c
// 排队标签（侵入式节点）：只存“下一个标签的位置”，没有任何学生信息
struct LineTag {
    LineTag* next;  // 指向队伍里下一个人的标签
};

// 学生信息（业务数据）：嵌入了排队标签
struct Student {
    char name[20];  // 学生数据1：姓名
    int id;         // 学生数据2：学号
    LineTag tag;    // 贴在学生身上的排队标签（侵入式节点）
};
```

排队的时候，只需要改动“标签上的 next”，不用动学生的姓名、学号这些数据。比如让学号 `101->102->103` 排队：

```c
// 创建3个学生（带标签）
struct Student zhangsan = {"张三", 101, NULL};
struct Student lisi = {"李四", 102, NULL};
struct Student wangwu = {"王五", 103, NULL};

// 排队：改标签的next，把学生串起来
zhangsan.tag.next = &lisi.tag;  // 张三的标签指向李四的标签
lisi.tag.next = &wangwu.tag;    // 李四的标签指向王五的标签
```



### container_of 宏

`container_of` 是 C 语言中一个“反向地址计算”的宏，利用结构体中某个成员的已知地址，反推出整个结构体的起始地址。它是侵入式数据结构的核心工具，从嵌入的节点指针（如链表的 `next`、哈希表的 `node`）中找到对应的业务数据。

在上面的示例中，`Student` 会嵌入一个 “结构节点” `LineTag`，而数据结构的操作（遍历、查找）只能拿到节点的地址 `LineTag*`。但我们最终需要访问的是整个业务数据（如学生的姓名、学号），这就需要从 “节点地址” 反推 “业务数据地址”。

`container_of` 的计算依赖于两个关键参数：

1. 成员在结构体中的**偏移量**（通过`offsetof`宏获取）；
2. 指针的**地址减法运算**（用成员地址减去偏移量，得到结构体起始地址）。

下面是简化版的宏定义：

```c
// ptr：已知的成员地址（如LineTag*）
// type：结构体类型（如struct Student）
// member：成员名（如tag）
#define container_of(ptr, type, member) \
    ((type *)((char *)(ptr) - offsetof(type, member)))
```

其中 `offsetof(type, member)` 的作用是计算 `member` 在 `type` 结构体中的偏移量（单位：字节），例如 `offsetof(struct Student, tag)` 就是 `tag` 成员距离 `struct Student` 起始地址的字节数；`(char *)(ptr)` 是将成员指针转为 `char*`，确保减法运算按 “1 字节” 为单位（避免指针类型导致的步长问题）；然后是成员地址减去偏移量，得到结构体的起始地址；最后强制转换为 `type*`，得到业务数据的指针。

例如计算上例中 “张三” 的起始地址：

```c
// 已知：tag成员的地址
struct LineTag* tag_ptr = &zhangsan.tag;
printf("tag的地址：%p\n", tag_ptr);  			// 假设输出：0x7ffd6b9e7a38（示例值）
    
// 用container_of计算Student的起始地址
struct Student* stu_ptr = container_of(tag_ptr, struct Student, tag);
    
printf("Student的地址：%p\n", stu_ptr);  	// 应该输出：0x7ffd6b9e7a20（示例值）
printf("验证姓名：%s\n", stu_ptr->name);  // 输出：张三（正确访问业务数据）
```

`container_of` 通过精确的偏移量计算，确保指针指向整个结构体的起始位置。



### 优势

侵入式数据结构的优势可以总结为 “快、省、灵” 三个字，每个优势都对应着它和非侵入式结构（比如 C++ STL 的`std::list`）的核心差异。

1. 侵入式结构中可直接从标签地址通过 `container_of` 宏获取数据，避免非侵入式结构额外的指针间接访问（如`void*`的 “指针追逐”），数据访问速度更快，对于频繁操作的场景（比如 Redis 每秒百万次哈希表查询），这种 “少一步” 的优势会被无限放大。

> 非侵入式：`LineTag`里存 `Student*`，访问时要 `tag->stu_ptr->name`（两步）；
>
> 侵入式：`LineTag` 在 `Student` 里，访问时 `container_of(tag, Student, tag)->name`（一步）。

2. 侵入式结构只需要管业务数据的内存，标签（结构节点）是业务数据的一部分，降低内存泄露风险。比如 `Student` 里的 `LineTag`，创建 `Student` 时标签自动存在，删除 `Student` 时标签也跟着消失，不用单独为标签分配 / 释放内存。
3. 非侵入式结构里，一个业务数据只能属于一个结构。比如一个学生要么在 “排队链表” 里，要么在 “分组链表” 里，想同时在两个链表，就得复制两份学生数据（或存两份指针），既浪费内存又容易出现数据不一致，而侵入式结构支持 “一个数据贴多个标签”，业务数据可以嵌入多个结构节点，同时属于多个数据结构（如同时嵌入哈希表节点 `HashNode` 和树节点  `TreeNode`），满足 Redis 等场景中 “同一数据多索引” 的需求（如有序集合同时按名称和分数索引）。
4. 非侵入式结构如果要支持多种数据类型，要么用`void*`（丢失类型检查，容易出错），要么用模板（比如 C++ `std::list<T>`，每种 `T` 都会生成一套重复代码，增加编译后体积）。而侵入式结构只要 “所有数据都贴同一种标签”，就能用同一套结构代码处理，例如学生贴 `LineTag` 能排队，老师贴 `LineTag` 也能排队，不用为学生、老师各写一套链表代码，同一套遍历、插入、删除逻辑就能通用，既减少代码冗余，又降低维护成本。

侵入式结构的优势本质是 “让数据自己承载结构关系”，而不是 “用结构包裹数据”，少了一层 “包裹”，就少了性能损耗、内存开销和适配限制，因此在 Linux 内核、Redis 等高性能场景中被广泛使用。



### 应用

| 场景维度 | 优先选非侵入式数据结构                  | 优先选侵入式数据结构                     |
| -------- | --------------------------------------- | ---------------------------------------- |
| 开发场景 | 日常业务开发（如电商订单、管理系统）    | 底层系统 / 高性能中间件（如内核、Redis） |
| 核心需求 | 开发效率、通用性、低维护成本            | 极致性能、内存优化、多索引共享           |
| 编程语言 | C++、Java、Python 等带泛型 / 模板的语言 | C 语言（无模板）、需深度性能优化的场景   |
| 典型案例 | Java 的`HashMap`、C++ 的`std::vector`   | Linux 内核`list_head`、Redis 哈希表节点  |

在日常业务开发中，非侵入式数据结构的应用更广泛，因为它降低了开发门槛，在开发效率、通用性和维护成本上对开发人员更友好；而非侵入式数据结构在性能敏感、底层系统、多索引场景中是无可替代的，例如 Linux 内核、Redis、Nginx 等底层软件。



### 参考文献

```tex
{
  author = "James Smith",
  title = "08. Hashtables",
  type = "Online book",
  booktitle = "Build Your Own Redis with C/C++",
  url = "https://build-your-own.org/redis/08_hashtables"
}
```













