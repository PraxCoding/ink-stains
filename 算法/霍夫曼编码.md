## 霍夫曼编码



### 变长码

<div align="center">
  <img src="assets/Morse.svg">
</div>

**变长码**的核心思想是使用不同长度的比特序列来代表不同的字符，以期获得比定长码更高的压缩效率。上图中的莫尔斯码表格是一个经典的变长码实例，它通过点（•）和划（—）的不同组合来编码字母和数字。

然而，由于码字长度不固定，如果某个码字恰好是另一个码字的前缀（例如，S（•••）是V（•••—）的前缀），解码器在遇到比特流“•••—”时将无法唯一确定它代表的是字母“V”还是字母“S”与一个后续字符的开始，进而产生**歧义性**。。

为了解决这一根本性问题，在实践中常采用插入**间隔**的方法，即在每个码字之间加入一个短暂的停顿（或称“间隙”），从而在物理层面上明确每个码字的边界。

### 解决方案

1. 固定长度码：所有码字长度相同。由于长度一致，自然不会出现 “一个码字是另一个前缀” 的情况，但编码效率可能较低（无法根据字符频率分配长短码）。
2. 给每个码字添加特殊停止字符：过在每个码字后添加 “停止符”（如特殊比特或符号），明确码字的结束边界，从而避免前缀歧义。
3. 一般前缀码：设计码字时，确保任意两个码字互不为前缀。这种方式兼具 “变长码的高效性”（高频字符用短码，低频用长码）和 “无歧义性”，是数据压缩中霍夫曼编码等算法的核心思想。

前缀码也是理论上的最优解决方案，即设计一个码表，其中没有任何一个码字是其他码字的前缀，从而从编码方案本身根除歧义的可能性，无需依赖物理间隔。

### 前缀码表示

<div align="center">
  <img src="assets/Trie.svg" height="300">
</div>

使用二叉 Trie 树来表示前缀码，每个分支代表比特“0”或“1”，所有字符仅出现在叶子节点，码字是从根节点到叶子节点的路径。而且，因为只有叶子节点存储字符，因此**没有任何码字是另一个码字的前缀**（否则会出现 “非叶子节点存储字符” 的矛盾），从而从结构上保证了 “前缀码” 的无歧义性。



### 参考文献

```tex
{
  author = "Robert Sedgewick, Kevin Wayne",
  title = "5.5 DATA COMPRESSION (Huffman compression)",
  type = "Online Lecture Note (Keynote)",
  booktitle = "Algorithms (Fourth Edition)",
  url = "https://algs4.cs.princeton.edu/lectures/keynote/55DataCompression.pdf",
  publisher = "Princeton University"
}
```









