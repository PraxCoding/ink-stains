## 霍夫曼编码



### 变长码

<div align="center">
  <img src="assets/Morse.svg">
</div>

**变长码**的核心思想是使用不同长度的比特序列来代表不同的字符，以期获得比定长码更高的压缩效率。上图中的莫尔斯码表格是一个经典的变长码实例，它通过点（•）和划（—）的不同组合来编码字母和数字。

然而，由于码字长度不固定，如果某个码字恰好是另一个码字的前缀（例如，S（•••）是V（•••—）的前缀），解码器在遇到比特流“•••—”时将无法唯一确定它代表的是字母“V”还是字母“S”与一个后续字符的开始，进而产生**歧义性**。。

为了解决这一根本性问题，在实践中常采用插入**间隔**的方法，即在每个码字之间加入一个短暂的停顿（或称“间隙”），从而在物理层面上明确每个码字的边界。

### 解决方案

1. 固定长度码：所有码字长度相同。由于长度一致，自然不会出现 “一个码字是另一个前缀” 的情况，但编码效率可能较低（无法根据字符频率分配长短码）。
2. 给每个码字添加特殊停止字符：过在每个码字后添加 “停止符”（如特殊比特或符号），明确码字的结束边界，从而避免前缀歧义。
3. 一般前缀码：设计码字时，确保任意两个码字互不为前缀。这种方式兼具 “变长码的高效性”（高频字符用短码，低频用长码）和 “无歧义性”，是数据压缩中霍夫曼编码等算法的核心思想。

前缀码也是理论上的最优解决方案，即设计一个码表，其中没有任何一个码字是其他码字的前缀，从而从编码方案本身根除歧义的可能性，无需依赖物理间隔。

### 前缀码表示

<div align="center">
  <img src="assets/Trie.svg" height="300">
</div>

使用二叉 Trie 树来表示前缀码，每个分支代表比特“0”或“1”，所有字符仅出现在叶子节点，码字是从根节点到叶子节点的路径。而且，因为只有叶子节点存储字符，因此**没有任何码字是另一个码字的前缀**（否则会出现 “非叶子节点存储字符” 的矛盾），从而从结构上保证了 “前缀码” 的无歧义性。

### 压缩与解压

1. 实现压缩有两条路径：

- （基于 Trie 树路径）：从 Trie 的叶子节点（对应字符）出发，沿路径回溯到根节点，记录路径上的"0/1"比特串，最后将这些比特反转，得到该字符的码字。
- （基于符号表）：建立“字符-码字”的键值对应表，直接通过查表将每个字符替换为对应的码字，拼接成压缩比特串。

2. 解压基于 Trie 树的遍历逻辑，步骤如下：

> - 从 Trie 的**根节点**开始；
> - 按比特串的顺序，遇到 “0” 则**左走**，遇到 “1” 则**右走**；
> - 一旦到达**叶子节点**，输出该节点对应的字符，然后**回到根节点**，继续处理剩余比串。

### Huffman 编码概述

霍夫曼编码是**动态的**，即会为**每个消息**定制专属的前缀码（前缀码的核心是 “无码字互为前缀”，避免解码歧义）。这种定制化设计能适配不同消息的字符频率分布，最大化压缩效率。

在压缩流程中，首先读取待压缩的原始消息；接着，基于消息内字符的出现频率为其构建最优前缀码，按照霍夫曼编码的核心逻辑，对高频字符分配短码、低频字符分配长码，以此实现 “最优” 的编码效果；之后，将构建好的前缀码以 Trie 树的形式写入文件；最后，利用该定制的前缀码将原始消息编码为压缩比特串，完成压缩操作。

在解压缩流程中，首先从文件中读取存储的前缀码 Trie 树结构；随后读取压缩后的比特串，通过遍历 Trie 树来还原原始消息：按比特依次选择 “0” 或 “1” 分支，一旦遇到叶子节点就输出对应字符，然后回到根节点继续处理剩余比特，最终完整还原出原始消息。



### 参考文献

```tex
{
  author = "Robert Sedgewick, Kevin Wayne",
  title = "5.5 DATA COMPRESSION (Huffman compression)",
  type = "Online Lecture Note (Keynote)",
  booktitle = "Algorithms (Fourth Edition)",
  url = "https://algs4.cs.princeton.edu/lectures/keynote/55DataCompression.pdf",
  publisher = "Princeton University"
}
```









